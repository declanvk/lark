//! We use `datafrog` to implement the actual inference.

use crate::full_inference::constraint::Constraint;
use crate::full_inference::constraint::ConstraintAt;
use crate::full_inference::perm::Perm;
use crate::full_inference::perm::PermData;
use crate::full_inference::perm::PermVar;
use crate::full_inference::FullInferenceTables;
use datafrog::Iteration;
use datafrog::Relation;
use lark_collections::FxIndexMap;
use lark_collections::FxIndexSet;
use lark_intern::Intern;
use lark_intern::Untern;
use lark_ty::PermKind;

/*

## Datalog rules

For each permission variable P, we have two relations we are computing:

```
borrow(P)
owned(P)
```

The rules are derived from the base constraints generated by the
program. We expect the following input relations:

```
perm_less0(Pa, Pb).
perm_condition0(Pc, Pa, Pb).
```

Our rules are then:

```
perm_less(Pa, Pb) :- perm_less0(Pa, Pb).

perm_less(Pa, Pb) :- perm_condition0(Pc, Pa, Pb), borrow(Pc).

borrow(Pb) :-
  perm_less(Pa, Pb),
  borrow(Pa).

owned(Pb) :-
  perm_less(Pa, Pb),
  owned(Pa).
```

*/

crate fn inference(
    db: &impl AsRef<FullInferenceTables>,
    constraints: &FxIndexSet<ConstraintAt>,
) -> FxIndexMap<PermVar, PermKind> {
    let mut iteration = Iteration::new();

    let perm_less = iteration.variable::<(Perm, Perm)>("perm_less");
    perm_less.insert(Relation::from(constraints.iter().flat_map(|c| {
        let (p_a, p_b) = match c.constraint {
            Constraint::PermEquateConditionally { .. } => (None, None),
            Constraint::PermEquate { a, b } => (Some((a, b)), Some((b, a))),
            Constraint::PermPermits { a, b } => (Some((b, a)), None),
        };

        p_a.into_iter().chain(p_b)
    })));

    let perm_condition0 = iteration.variable::<(Perm, (Perm, Perm))>("perm_condition");
    perm_condition0.insert(Relation::from(constraints.iter().flat_map(|c| {
        let (p_a, p_b) = match c.constraint {
            Constraint::PermEquateConditionally { condition, a, b } => {
                (Some((condition, (a, b))), Some((condition, (b, a))))
            }
            Constraint::PermEquate { .. } => (None, None),
            Constraint::PermPermits { .. } => (None, None),
        };

        p_a.into_iter().chain(p_b)
    })));

    let perm_borrow: Perm = PermKind::Borrow.intern(db);
    let perm_own: Perm = PermKind::Own.intern(db);

    let borrow = iteration.variable::<(Perm, ())>("borrow");
    borrow.insert(Relation::from(
        std::iter::once((perm_borrow, ())).chain(std::iter::once((perm_own, ()))),
    ));

    let owned = iteration.variable::<(Perm, ())>("borrow");
    owned.insert(Relation::from(std::iter::once((perm_own, ()))));

    while iteration.changed() {
        // perm_less(Pb) :- perm_condition(Pc, Pa, Pb), borrow(Pc).
        perm_less.from_join(&perm_condition0, &borrow, |&_p_c, &(p_a, p_b), &()| {
            (p_a, p_b)
        });

        // borrow(Pb) :- perm_less(Pa, Pb), borrow(Pa).
        borrow.from_join(&perm_less, &borrow, |&_p_a, &p_b, &()| (p_b, ()));

        // owned(Pb) :- perm_less(Pa, Pb), owned(Pa).
        owned.from_join(&perm_less, &owned, |&_p_a, &p_b, &()| (p_b, ()));
    }

    let borrow = borrow.complete();
    let owned = owned.complete();

    let mut set: FxIndexMap<PermVar, PermKind> = FxIndexMap::default();
    set.extend(
        borrow
            .elements
            .iter()
            .filter_map(|&(v, ())| match v.untern(db) {
                PermData::Inferred(v) => Some((v, PermKind::Borrow)),
                PermData::Known(_) | PermData::Placeholder(_) => None,
            }),
    );
    set.extend(
        owned
            .elements
            .iter()
            .filter_map(|&(v, ())| match v.untern(db) {
                PermData::Inferred(v) => Some((v, PermKind::Own)),
                PermData::Known(_) | PermData::Placeholder(_) => None,
            }),
    );
    set
}
